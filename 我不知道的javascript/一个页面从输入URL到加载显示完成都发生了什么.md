# 一个页面从输入URL到加载显示完成都发生了什么

## 浏览器的进程
浏览器是多进程的，有一个主控进程，每一个tab页面都会新开一个渲染进程。
- 插件进程
- GPU进程
- 浏览器渲染进程（内核）
- 等等

每一个tab页面可以看做是浏览器的一个渲染进程，这个进程本身是多线程的，主要有：
- GUI线程
    - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和render树，布局、绘制等
    - 需要repaint或者reflow时，该线程就会执行
    - GUI线程和js线程是互斥的
- JS引擎线程
    - 也就是js内核，处理js脚本，运行程序（例如大V8）
    - 一直等着任务队列中任务的到来然后加以处理
    - 一个渲染进程中只有一个js线程
    - 因为和GUI线程互斥，所以js执行过长，会阻塞页面渲染
- 事件触发线程
    - 是一个单独的线程，并不属于js引擎
    - 当遇到setTimeOut、鼠标点进、AJAX请求等，会将对应的任务添加到事件线程
    - 因为js引擎单线程的原因，队列中的事件需要排队等待处理
- 定时器线程
    - 传说中的setInterval与setTimeout所在线程
    - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
    - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
- 网络请求线程
    - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

### 浏览器为什么要是多进程的
- 避免单个page crash影响整个浏览器
- 避免第三方插件crash影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

### 解析URL

输入URL后，会首先进行解析：
- protocol
- host
- path
- query
- fragment

### 如何解决js单线程面对CPU密集型计算的问题

- js引擎是单线程的，而且JS执行时间过长会阻塞页面
- 所以后来有了Web Worker



# 从开启网络线程到发出完整的http请求

## DNS查询
- 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host
- 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP
- 需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化

## tcp/ip

## OSI七层网络模型
- 应用层
    - DNS、HTTP、SMTP等
    - 在应用层交互的数据单元称之为报文
- 表示层
    - 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）
    - 格式有，JPEG、ASCll、EBCDIC、加密格式等 
- 会话层
    - 建立、管理、终止会话。（在五层模型里面已经合并到了应用层）
    - 对应主机进程，指本地主机与远程主机正在进行的会话
- 传输层
    - 定义传输数据的协议端口号，以及流控和差错校验。
    - 协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层
- 网络层
    - 进行逻辑地址寻址，实现不同网络之间的路径选择。
    - 协议有：ICMP IGMP IP（IPV4 IPV6）
- 数据链路层
    - 建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）
将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。
- 物理层
    - 建立、维护、断开物理连接。（由底层网络定义协议）
TCP/IP 层级模型结构，应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。


# 参考文档

- [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872#comment-area)
- [从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！](http://www.dailichun.com/2018/03/12/whenyouenteraurl.html)