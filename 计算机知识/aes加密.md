
# AES加密算法基本原理

## aes是一种对称加密算法

对称加密就是说加密和解密用的同一个秘钥，与之相对的是非对称加密。

## aes在加密时候会分成很多轮加密

每一轮做的工作其实是几乎一样的，只是每轮的秘钥不一样。举个例子吧，假设在一次AES加密过程中分为三轮。那么我们秘钥就会根据某种方法变换三次，于是我们得到了四个秘钥：原始秘钥、密钥A、密钥B、密钥C。

原始秘钥->密钥A->密钥B->密钥C (每个箭头代表一次变换)

下面是每一个密钥所对应的轮

密钥A->第一轮

密钥B->第二轮

密钥C->第三轮

## 在AES中任何计算都是以矩阵为单位的

在AES中任何计算都是以矩阵为单位的，无论秘钥还是数据原文。常见的 4x4 矩阵, 5x5矩阵。

对于4*4的矩阵，每个格子代表八位的二进制数据，那么一共8 * 4 * 4 = 128，所谓的128位的AES算法指的就是这个意思，常见的还有192、256位等。

## AES在一轮加密中有四部分

### 字节替代

字节替代主要是把矩阵每个格子的数据进行一个字典的映射。

取每个数据的前四位和后四位二进制，用16 * 16的二维数组进行查找。

这个字典是用某种算法实现的比较安全的字典，暂时不深入研究。

与之相对应的也有一个用于解密的逆向字典用于解密。

### 行移位

行移位，行移位，就是移动行嘛，实际上操作便是将每一行进行移动。

1. 第一行不动，
2. 第二行向右移动一位，
3. 第三行向右移动俩位，
4. 第四行向右移动三位。（向左移动一位）

### 列混淆

矩阵存在一种运算，AB=C，那么存在D使得 A=CD。D和B一一对应。即可以用B加密，用D解密。

在标准AES中矩阵B和D都是固定的，不会变化（这里可以实现一个，可以防住大部分人）。

矩阵运算有个问题，容易溢出，这里是用数学上一个叫做有限域的东西解决的，有点复杂，这里不展开。

### 加轮秘钥

前面都是对原始数据进行操作，这一次就是秘钥发挥作用的时候了。秘钥部分其实比较简单，就是用数据和秘钥进行一一对应的异或运算。异或计算的基本规则如下：
- 如果两个值不同，则异或结果为1
- 如果两个值相同，则异或结果为0

异或运算有个特点，异或的结果再和秘钥异或能还原回去。


# crypto-js库

`crypto-js`是js实现的加密库，其中也实现了AES加密。

```js
function getAESData(data, key, iv = ) {
    const aesKey = CryptoJS.enc.Utf8.parse(key);
    const aesIv = CryptoJS.enc.Utf8.parse(iv);
    const aesData = data;
    return CryptoJS.AES.decrypt(aesData, aesKey, {
        iv: aesIv,
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    }).toString(CryptoJS.enc.Utf8);
```

## CryptoJS.enc.Utf8.parse

enc下面主要是指定字符编码模式的API，加密算法的入参都是一些特殊格式的，需要这里去解析一下。

## mode
AES分为几种模式，比如ECB，CBC，CFB等等，这些模式除了ECB由于没有使用IV而不太安全，其他模式差别并没有太明显，大部分的区别在IV和KEY来计算密文的方法略有区别。

## iv
iv是偏移向量，不同的IV加密后的字符串是不同的，加密和解密需要相同的IV，既然IV看起来和key一样，却还要多一个IV的目的，对于每个块来说，key是不变的，但是只有第一个块的IV是用户提供的，其他块IV都是自动生成。

## padding
AES块加密说过，PADDING是用来填充最后一块使得变成一整块，所以对于加密解密两端需要使用同一的PADDING模式，大部分PADDING模式为PKCS5, PKCS7, NOPADDING。


# 参考文档
- [AES加密算法原理及其实现（小学生不一定也能看懂版）](https://zhuanlan.zhihu.com/p/702060967)
- [前端如何理解AES加解密](https://zhuanlan.zhihu.com/p/543366122)